## 데이터 교환 포맷: JSON, XML, YAML
데이터 교환 포맷은 서로 다른 시스템 간에 데이터를 구조화하고 전송하는 데 사용되는 표준화된 형식입니다.

### JSON (JavaScript Object Notation) 💎
 JavaScript 객체 리터럴에서 영감을 받은 경량의 데이터 교환 포맷입니다. 사람이 읽고 쓰기 쉬우며, 기계가 파싱하고 생성하기도 용이합니다.

#### 특징
key-value 쌍으로 데이터를 표현합니다.

배열과 객체(사전) 두 가지 주요 구조를 가집니다.

숫자, 문자열, 불리언, null, 객체, 배열 타입을 지원합니다.

XML에 비해 더 간결하고 가볍습니다.

#### 장점
간결성: 문법이 단순하여 가독성이 높고 파일 크기가 작습니다.

호환성: 대부분의 프로그래밍 언어에서 기본적으로 지원하거나 라이브러리가 잘 구축되어 있습니다. 웹 환경(특히 JavaScript)에서 강력한 네이티브 지원을 받습니다.

성능: 파싱 속도가 빠릅니다.

#### 단점

데이터 타입 제한: XML에 비해 표현할 수 있는 데이터 타입이 적습니다 (예: 주석을 지원하지 않음).

스키마 정의의 부재: 자체적으로 스키마를 정의하는 표준 방식이 없어, 데이터 유효성 검사에 추가적인 도구가 필요할 수 있습니다 (JSON Schema 사용).

### XML (Extensible Markup Language) 📜
W3C에서 개발한 마크업 언어로, 데이터 저장 및 전송을 위해 설계되었습니다. 사람과 기계 모두에게 읽기 쉬운 형식으로 데이터를 구조화합니다.

#### 특징

태그(Tag) 기반의 계층적 구조를 가집니다. HTML과 유사하지만, 미리 정의된 태그 집합이 없고 사용자가 직접 태그를 정의할 수 있어 확장 가능합니다.

속성(Attribute)을 사용하여 추가 정보를 표현할 수 있습니다.

스키마 정의: DTD(Document Type Definition)나 XML Schema를 통해 문서의 구조와 유효성을 엄격하게 정의할 수 있습니다.

#### 장점

강력한 구조 정의: 복잡하고 계층적인 데이터 구조를 표현하는 데 매우 강력합니다.

유효성 검증: 스키마를 통해 데이터의 일관성과 정확성을 강제할 수 있습니다.

확장성: 사용자 정의 태그를 통해 어떤 종류의 데이터도 표현할 수 있습니다.

#### 단점

장황함: 시작 태그와 종료 태그를 모두 사용하고 속성을 포함하여 JSON보다 파일 크기가 크고 가독성이 떨어질 수 있습니다.

파싱 복잡성: 파싱이 JSON에 비해 더 복잡하고 리소스가 많이 소모될 수 있습니다.

최근 사용 감소: 웹 API에서는 JSON에 밀려 사용이 줄어드는 추세입니다 (SOAP 웹 서비스 등에서는 여전히 사용).

### YAML (YAML Ain't Markup Language) 📝
사람이 읽기 쉬운 데이터 직렬화 표준입니다. 주로 설정 파일, 데이터 교환, 프로세스 간 메시징 등에 사용됩니다.

#### 특징
들여쓰기(Indentation)를 사용하여 데이터의 계층 구조를 나타냅니다 (파이썬과 유사).

주석을 지원합니다.

다양한 스칼라 타입(문자열, 숫자, 불리언, null)과 복합 타입(리스트, 맵)을 지원합니다.

JSON의 상위 집합(superset)이므로, 유효한 JSON 파일은 유효한 YAML 파일입니다.

#### 장점

뛰어난 가독성: 들여쓰기 기반으로 매우 깔끔하고 읽기 쉽습니다.

설정 파일에 적합: 복잡한 설정 정보를 관리하는 데 탁월합니다 (Docker Compose, Kubernetes 등에서 널리 사용).

주석 지원: 설정 파일에 설명을 추가하기 용이합니다.

#### 단점

들여쓰기 오류: 들여쓰기 오류에 매우 민감하여 사소한 공백 문제로도 파싱 오류가 발생할 수 있습니다.

학습 곡선: JSON이나 XML에 비해 초기 학습에 약간의 시간이 필요할 수 있습니다.

#### 시리얼라이제이션 (Serialization) 🔄
객체(Object)나 데이터 구조를 저장하거나 전송 가능한 형식(예: 바이트 스트림, JSON 문자열, XML 문서)으로 변환하는 과정입니다.

#### 역할
영속성(Persistence): 프로그램 종료 후에도 데이터를 유지하기 위해 파일 시스템이나 데이터베이스에 저장할 수 있는 형태로 변환합니다.

네트워크 전송: 네트워크를 통해 다른 애플리케이션이나 서비스로 데이터를 전송하기 위해 표준화된 포맷으로 변환합니다.

데이터 교환: 서로 다른 프로그래밍 언어나 플랫폼 간에 데이터를 교환하기 위한 공통 형식으로 변환합니다.

예시: 자바스크립트 객체를 JSON 문자열로 변환하는 JSON.stringify() 메서드나, 파이썬 객체를 바이트 스트림으로 변환하는 pickle 모듈 등이 시리얼라이제이션의 예입니다.

#### 디시리얼라이제이션 (Deserialization): 시리얼라이즈된 데이터를 원래의 객체나 데이터 구조로 복원하는 역과정입니다. JSON.parse()가 대표적입니다.

### 비교
| 특성         | JSON             | XML              | YAML             |
|--------------|------------------|------------------|------------------|
| 문법 유형    | Key-Value 쌍     | 태그 마크업      | 들여쓰기 기반    |
| 가독성       | 높음             | 낮음             | 매우 높음        |
| 주석 지원    | 불가             | 가능             | 가능             |
| 스키마 지원  | 외부 라이브러리   | 내장(XML Schema) | 외부 라이브러리   |
| 오버헤드     | 낮음             | 높음             | 낮음             |
| 사용 편의성  | 매우 쉬움        | 중간             | 쉬움             |

---


## HTTPS와 SSL/TLS 인증서 🔒
HTTPS는 웹 통신의 보안을 담당하는 핵심 기술입니다. HTTP에 보안 기능이 추가된 버전입니다.

### HTTPS (Hypertext Transfer Protocol Secure) 🛡️
HTTP에 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜이 결합되어 데이터의 암호화, 무결성, 인증을 제공하는 보안 통신 프로토콜입니다.

#### HTTP의 문제점
HTTP는 데이터를 평문(Plaintext)으로 전송하므로, 중간에서 데이터를 가로채면(도청) 내용이 그대로 노출됩니다. 또한, 데이터 위변조나 서버 위장 등의 위험이 있습니다.

#### HTTPS의 해결책
암호화: 클라이언트와 서버 간에 주고받는 모든 데이터를 암호화하여 제3자가 내용을 엿볼 수 없게 합니다. (대칭키 및 비대칭키 암호화 사용)

무결성: 데이터가 전송 중에 변조되지 않았음을 보장합니다. (해시 함수 사용)

인증: 클라이언트가 접속하려는 서버가 위조되지 않았음을 확인하고, 때로는 서버가 클라이언트를 확인할 수도 있습니다. (SSL/TLS 인증서 사용)

#### 작동 원리

1. 클라이언트가 서버에 연결 요청
2. 서버가 SSL/TLS 인증서 전송
3. 클라이언트가 인증서 검증 및 공개키 확보
4. 대칭키(session key) 생성 및 서버에 암호화 전송
5. 대칭키 기반 암호화 통신 수행

## SSL/TLS 인증서 📜🔑
서버의 신원(identity)을 증명하고, 클라이언트와 서버 간의 암호화된 통신 채널을 설정하는 데 사용되는 전자 문서입니다. 공신력 있는 인증 기관(CA: Certificate Authority)이 발급합니다.
SSL vs TLS: SSL은 초기 버전의 프로토콜이고, TLS는 SSL 3.0의 후속 버전입니다. 현재는 일반적으로 TLS가 사용되지만, "SSL 인증서"라는 용어가 더 흔하게 사용됩니다.

### 인증서 구성 요소

도메인 이름: 인증서를 사용할 도메인

발급자(CA): 신뢰할 수 있는 인증 기관(Certificate Authority)

공개키(Public Key): 클라이언트가 대칭키를 암호화할 때 사용

유효 기간(Validity Period): 인증서 사용 가능 기간

서명(Signature): 발급자의 디지털 서명으로 위변조 방지

### 인증서 종류

도메인 검증(DV): 도메인 소유권 확인

기업 검증(OV): 조직 정보 확인

확장 검증(EV): 엄격한 기업 및 법적 실체 검증

#### 갱신 및 관리

만료 전 갱신 필요

프라이빗 키 관리 주의

자동 갱신(Auto-Renewal) 설정 권장

### SSL/TLS 인증서 검증 과정🕵️
- 인증서 수신
클라이언트(웹 브라우저)는 서버로부터 SSL/TLS 인증서를 받습니다.

- 만료일 확인
인증서의 유효 기간이 지났는지 확인합니다.

- 도메인 일치 확인
인증서에 명시된 도메인 이름이 현재 접속하려는 도메인과 일치하는지 확인합니다.

- 신뢰할 수 있는 CA 확인
클라이언트는 인증서에 포함된 CA의 디지털 서명을 검증합니다.

- 이를 위해 클라이언트의 운영체제나 브라우저에 미리 설치된 루트 인증서(Root Certificate) 목록에서 해당 CA의 공개키를 찾습니다.

- 루트 인증서가 신뢰할 수 있는 CA에 의해 발급된 것인지 확인하고, 이를 바탕으로 서버 인증서의 서명을 검증합니다.

- 인증서 체인(Certificate Chain)
실제 서버 인증서는 중간 CA에 의해 발급되는 경우가 많으며, 이 중간 CA의 인증서는 다시 루트 CA에 의해 발급됩니다. 클라이언트는 이 전체 체인을 따라가며 각 인증서가 신뢰할 수 있는 상위 CA에 의해 서명되었는지 확인합니다.

- 유효성 판단
위 모든 검증 과정이 성공하면, 클라이언트는 서버를 신뢰하고 암호화된 통신을 시작합니다. 만약 하나라도 실패하면, 브라우저는 사용자에게 보안 경고를 표시합니다.
